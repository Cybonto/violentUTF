#!/usr/bin/env python3
"""
Simple test for Issue #282 Vulnerability Service Implementation (TDD Phase)

Testing only the vulnerability service components that are currently implemented.
"""

import pytest
import asyncio
from unittest.mock import Mock
from uuid import uuid4
from datetime import datetime, timedelta

# Test only what we've implemented so far
try:
    from violentutf_api.fastapi_app.app.services.risk_assessment.vulnerability_service import (
        VulnerabilityAssessmentService,
        Vulnerability,
        VulnerabilityAssessment,
        RemediationRecommendation,
        VulnerabilitySeverity,
    )
    from violentutf_api.fastapi_app.app.models.risk_assessment import (
        DatabaseAsset,
        AssetType,
        SecurityClassification,
        CriticalityLevel,
    )
    IMPORTS_AVAILABLE = True
except ImportError as e:
    print(f"Import error: {e}")
    IMPORTS_AVAILABLE = False


class TestVulnerabilityService:
    """Test the vulnerability assessment service"""
    
    @pytest.fixture
    def mock_postgresql_asset(self):
        """Create a mock PostgreSQL asset for testing"""
        asset = Mock()
        asset.id = uuid4()
        asset.name = "Test PostgreSQL Database"
        asset.asset_type = "postgresql"
        asset.database_version = "14.9"
        asset.location = "us-east-1"
        asset.security_classification = "confidential"
        asset.criticality_level = "high"
        asset.access_restricted = True
        asset.encryption_enabled = True
        asset.technical_contact = "dba@example.com"
        asset.environment = "production"
        return asset
    
    @pytest.fixture
    def mock_sqlite_asset(self):
        """Create a mock SQLite asset for testing"""
        asset = Mock()
        asset.id = uuid4()
        asset.name = "Test SQLite Database"
        asset.asset_type = "sqlite"
        asset.database_version = "3.42.0"
        asset.location = "local"
        asset.security_classification = "internal"
        asset.criticality_level = "medium"
        asset.access_restricted = False
        asset.encryption_enabled = False
        asset.technical_contact = "dev@example.com"
        asset.environment = "development"
        return asset
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    def test_vulnerability_service_initialization(self):
        """Test VulnerabilityAssessmentService can be initialized"""
        service = VulnerabilityAssessmentService()
        assert service is not None
        assert service.nvd_api_key is None
        assert service.cache_duration_hours == 24
        assert isinstance(service.vulnerability_cache, dict)
        assert len(service.latest_versions) > 0
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    def test_vulnerability_service_with_api_key(self):
        """Test VulnerabilityAssessmentService initialization with API key"""
        api_key = "test_api_key_12345"
        service = VulnerabilityAssessmentService(nvd_api_key=api_key, cache_duration_hours=12)
        
        assert service.nvd_api_key == api_key
        assert service.cache_duration_hours == 12
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_generate_cpe_identifiers_postgresql(self, mock_postgresql_asset):
        """Test CPE identifier generation for PostgreSQL"""
        service = VulnerabilityAssessmentService()
        
        cpe_identifiers = await service.generate_cpe_identifiers(mock_postgresql_asset)
        
        assert len(cpe_identifiers) > 0
        assert any("postgresql" in cpe for cpe in cpe_identifiers)
        assert any("14.9" in cpe for cpe in cpe_identifiers)
        assert all(cpe.startswith("cpe:2.3:a:") for cpe in cpe_identifiers)
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_generate_cpe_identifiers_sqlite(self, mock_sqlite_asset):
        """Test CPE identifier generation for SQLite"""
        service = VulnerabilityAssessmentService()
        
        cpe_identifiers = await service.generate_cpe_identifiers(mock_sqlite_asset)
        
        assert len(cpe_identifiers) > 0
        assert any("sqlite" in cpe for cpe in cpe_identifiers)
        assert any("3.42.0" in cpe for cpe in cpe_identifiers)
        assert all(cpe.startswith("cpe:2.3:a:") for cpe in cpe_identifiers)
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_generate_cpe_identifiers_no_version(self):
        """Test CPE identifier generation when database version is unknown"""
        asset = Mock()
        asset.id = uuid4()
        asset.asset_type = "postgresql"
        asset.database_version = None  # No version information
        
        service = VulnerabilityAssessmentService()
        cpe_identifiers = await service.generate_cpe_identifiers(asset)
        
        assert len(cpe_identifiers) > 0
        assert any("*" in cpe for cpe in cpe_identifiers)  # Should use wildcard
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_search_vulnerabilities_by_cpe_mock(self):
        """Test vulnerability search using mock data"""
        service = VulnerabilityAssessmentService()
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        
        vulnerabilities = await service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        assert isinstance(vulnerabilities, list)
        # Should return mock PostgreSQL vulnerabilities
        if vulnerabilities:
            assert all(vuln.cve_id.startswith("CVE-") for vuln in vulnerabilities)
            assert all(isinstance(vuln.cvss_score, (int, float)) for vuln in vulnerabilities)
            assert all(0.0 <= vuln.cvss_score <= 10.0 for vuln in vulnerabilities)
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_vulnerability_caching(self):
        """Test vulnerability data caching mechanism"""
        service = VulnerabilityAssessmentService()
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        
        # First call - should populate cache
        vulnerabilities1 = await service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        # Second call - should use cache
        vulnerabilities2 = await service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        # Results should be the same (from cache)
        assert len(vulnerabilities1) == len(vulnerabilities2)
        if vulnerabilities1:
            assert vulnerabilities1[0].cve_id == vulnerabilities2[0].cve_id
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    def test_calculate_vulnerability_score_no_vulnerabilities(self):
        """Test vulnerability score calculation with no vulnerabilities"""
        service = VulnerabilityAssessmentService()
        
        score = service.calculate_vulnerability_score([])
        
        assert score == 1.0  # Lowest score for no vulnerabilities
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    def test_calculate_vulnerability_score_with_vulnerabilities(self):
        """Test vulnerability score calculation with mock vulnerabilities"""
        service = VulnerabilityAssessmentService()
        
        # Create mock vulnerabilities
        vulnerabilities = [
            Mock(
                cve_id="CVE-2023-1234",
                cvss_score=9.8,
                severity=VulnerabilitySeverity.CRITICAL,
                exploit_available=True,
                published_date=datetime.utcnow() - timedelta(days=15)  # Recent
            ),
            Mock(
                cve_id="CVE-2023-5678",
                cvss_score=7.5,
                severity=VulnerabilitySeverity.HIGH,
                exploit_available=False,
                published_date=datetime.utcnow() - timedelta(days=60)  # Older
            ),
            Mock(
                cve_id="CVE-2023-9012",
                cvss_score=5.2,
                severity=VulnerabilitySeverity.MEDIUM,
                exploit_available=False,
                published_date=datetime.utcnow() - timedelta(days=120)  # Old
            )
        ]
        
        score = service.calculate_vulnerability_score(vulnerabilities)
        
        assert isinstance(score, (int, float))
        assert 1.0 <= score <= 5.0
        assert score > 2.0  # Should be elevated due to critical vulnerability
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    def test_map_cvss_to_severity(self):
        """Test CVSS score to severity level mapping"""
        service = VulnerabilityAssessmentService()
        
        test_cases = [
            (0.0, VulnerabilitySeverity.NONE),
            (3.5, VulnerabilitySeverity.LOW),
            (5.5, VulnerabilitySeverity.MEDIUM),
            (8.0, VulnerabilitySeverity.HIGH),
            (9.5, VulnerabilitySeverity.CRITICAL)
        ]
        
        for cvss_score, expected_severity in test_cases:
            result = service.map_cvss_to_severity(cvss_score)
            assert result == expected_severity
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_check_exploit_availability(self):
        """Test exploit availability checking"""
        service = VulnerabilityAssessmentService()
        
        # Test known exploitable CVE
        result1 = await service.check_exploit_availability("CVE-2023-39417")
        assert isinstance(result1, bool)
        
        # Test unknown CVE
        result2 = await service.check_exploit_availability("CVE-9999-0000")
        assert isinstance(result2, bool)
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_get_latest_version(self):
        """Test latest version retrieval"""
        service = VulnerabilityAssessmentService()
        
        test_cases = ['postgresql', 'sqlite', 'duckdb', 'mysql', 'mongodb']
        
        for db_type in test_cases:
            version = await service.get_latest_version(db_type)
            assert version is not None
            assert isinstance(version, str)
            assert len(version) > 0
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_generate_remediation_recommendations(self, mock_postgresql_asset):
        """Test remediation recommendation generation"""
        service = VulnerabilityAssessmentService()
        
        # Create mock vulnerabilities requiring different remediation strategies
        vulnerabilities = [
            Mock(
                cve_id="CVE-2023-1234",
                description="SQL injection vulnerability fixed in version 15.4",
                cvss_score=9.8,
                severity=VulnerabilitySeverity.CRITICAL
            ),
            Mock(
                cve_id="CVE-2023-5678",
                description="Authentication bypass via configuration setting",
                cvss_score=7.5,
                severity=VulnerabilitySeverity.HIGH
            )
        ]
        
        recommendations = await service.generate_remediation_recommendations(
            mock_postgresql_asset, vulnerabilities
        )
        
        assert isinstance(recommendations, list)
        if recommendations:
            # Check that recommendations are properly structured
            for rec in recommendations:
                assert hasattr(rec, 'priority')
                assert hasattr(rec, 'action')
                assert hasattr(rec, 'description')
                assert hasattr(rec, 'affected_vulnerabilities')
                assert hasattr(rec, 'estimated_effort_hours')
                assert rec.priority > 0
                assert isinstance(rec.affected_vulnerabilities, list)
                assert rec.estimated_effort_hours > 0
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_assess_asset_vulnerabilities_complete(self, mock_postgresql_asset):
        """Test complete vulnerability assessment workflow"""
        service = VulnerabilityAssessmentService()
        
        assessment = await service.assess_asset_vulnerabilities(mock_postgresql_asset)
        
        assert isinstance(assessment, VulnerabilityAssessment)
        assert assessment.asset_id == str(mock_postgresql_asset.id)
        assert isinstance(assessment.assessment_date, datetime)
        assert isinstance(assessment.vulnerabilities, list)
        assert assessment.total_vulnerabilities >= 0
        assert assessment.critical_vulnerabilities >= 0
        assert assessment.high_vulnerabilities >= 0
        assert assessment.medium_vulnerabilities >= 0
        assert assessment.low_vulnerabilities >= 0
        assert 1.0 <= assessment.vulnerability_score <= 5.0
        assert isinstance(assessment.remediation_recommendations, list)
        assert isinstance(assessment.next_scan_date, datetime)
        assert assessment.next_scan_date > assessment.assessment_date
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_vulnerability_assessment_performance(self, mock_postgresql_asset):
        """Test vulnerability assessment performance (≤ 10 minutes requirement)"""
        service = VulnerabilityAssessmentService()
        
        start_time = datetime.utcnow()
        assessment = await service.assess_asset_vulnerabilities(mock_postgresql_asset)
        end_time = datetime.utcnow()
        
        execution_time = (end_time - start_time).total_seconds()
        
        assert isinstance(assessment, VulnerabilityAssessment)
        assert execution_time <= 600.0  # Performance requirement: ≤ 10 minutes
        
        # Check that scan duration is recorded
        if assessment.scan_duration_seconds:
            assert assessment.scan_duration_seconds <= 600
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Vulnerability service modules not available")
    @pytest.mark.asyncio
    async def test_asset_validation_errors(self):
        """Test asset validation error handling"""
        service = VulnerabilityAssessmentService()
        
        # Test with incomplete asset data
        incomplete_asset = Mock()
        incomplete_asset.id = None  # Missing ID
        incomplete_asset.name = ""  # Empty name
        incomplete_asset.asset_type = None  # Missing type
        
        with pytest.raises(ValueError):
            await service.assess_asset_vulnerabilities(incomplete_asset)


if __name__ == "__main__":
    # Run the tests
    pytest.main([__file__, "-v", "--tb=short"])