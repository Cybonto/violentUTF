#!/usr/bin/env python3
"""
Test suite for Issue #282: Vulnerability Assessment Service

This module contains comprehensive unit tests for the vulnerability assessment service
that integrates with NIST National Vulnerability Database (NVD) for real-time
CVE analysis and vulnerability scoring.

Tests cover:
- NIST NVD integration and API interaction
- CPE identifier generation for database assets
- CVSS score integration and vulnerability scoring
- Remediation recommendation engine
- Performance requirements (â‰¤ 10 minutes per scan)
- Error handling and resilience
"""

import pytest
import asyncio
import time
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from uuid import uuid4
from datetime import datetime, timedelta
from typing import List, Dict, Any
import json

# Import the modules we'll be testing (TDD approach - these don't exist yet)
try:
    from violentutf_api.fastapi_app.app.services.risk_assessment.vulnerability_service import (
        VulnerabilityAssessmentService,
        Vulnerability,
        VulnerabilityAssessment,
        RemediationRecommendation,
    )
    from violentutf_api.fastapi_app.app.models.risk_assessment import (
        DatabaseAsset,
        AssetType,
        SecurityClassification,
        CriticalityLevel,
    )
except ImportError:
    # TDD: These modules don't exist yet, so we'll create mock classes for testing
    pytest.skip("Vulnerability assessment modules not implemented yet - TDD phase", allow_module_level=True)


class TestVulnerabilityData:
    """Test fixtures and mock data for vulnerability assessments"""
    
    @pytest.fixture
    def mock_nvd_vulnerabilities(self):
        """Mock NIST NVD vulnerability data"""
        return [
            {
                "id": "CVE-2023-1234",
                "description": "SQL injection vulnerability in PostgreSQL extension",
                "score": 9.8,
                "severity": "CRITICAL",
                "published": "2023-01-15T00:00:00Z",
                "lastModified": "2023-01-20T00:00:00Z",
                "references": ["https://postgresql.org/security/CVE-2023-1234"],
                "cwe": ["CWE-89"]
            },
            {
                "id": "CVE-2023-5678",
                "description": "Authentication bypass in database connection handler",
                "score": 7.5,
                "severity": "HIGH", 
                "published": "2023-02-20T00:00:00Z",
                "lastModified": "2023-02-25T00:00:00Z",
                "references": ["https://security.example.com/CVE-2023-5678"],
                "cwe": ["CWE-287"]
            },
            {
                "id": "CVE-2023-9012",
                "description": "Information disclosure in SQLite FTS module",
                "score": 5.2,
                "severity": "MEDIUM",
                "published": "2023-03-10T00:00:00Z",
                "lastModified": "2023-03-15T00:00:00Z",
                "references": ["https://sqlite.org/security"],
                "cwe": ["CWE-200"]
            }
        ]
    
    @pytest.fixture
    def postgresql_asset(self):
        """Mock PostgreSQL database asset"""
        return Mock(
            id=uuid4(),
            name="Production PostgreSQL Database",
            asset_type="POSTGRESQL",
            database_version="14.9",
            location="us-east-1",
            security_classification="CONFIDENTIAL",
            criticality_level="HIGH",
            access_restricted=True,
            technical_contact="dba@example.com"
        )
    
    @pytest.fixture
    def sqlite_asset(self):
        """Mock SQLite database asset"""
        return Mock(
            id=uuid4(),
            name="Development SQLite Database",
            asset_type="SQLITE",
            database_version="3.42.0",
            location="local",
            security_classification="INTERNAL",
            criticality_level="MEDIUM",
            access_restricted=False,
            file_path="/data/dev.db"
        )
    
    @pytest.fixture
    def duckdb_asset(self):
        """Mock DuckDB database asset"""
        return Mock(
            id=uuid4(),
            name="Analytics DuckDB Database",
            asset_type="DUCKDB",
            database_version="0.8.1",
            location="local",
            security_classification="CONFIDENTIAL",
            criticality_level="HIGH",
            access_restricted=True,
            file_path="/data/analytics.duckdb"
        )


class TestVulnerabilityAssessmentService:
    """Test suite for VulnerabilityAssessmentService main functionality"""
    
    @pytest.fixture
    def vulnerability_service(self):
        """Create mock VulnerabilityAssessmentService"""
        service = Mock()
        service.nvd_api_key = "test_api_key"
        service.cache_duration_hours = 24
        service.vulnerability_cache = {}
        
        # Mock async methods
        service.assess_asset_vulnerabilities = AsyncMock()
        service.generate_cpe_identifiers = AsyncMock()
        service.search_vulnerabilities_by_cpe = AsyncMock()
        service.generate_remediation_recommendations = AsyncMock()
        service.check_exploit_availability = AsyncMock()
        service.get_latest_version = AsyncMock()
        
        # Mock sync methods
        service.deduplicate_vulnerabilities = Mock()
        service.calculate_vulnerability_score = Mock()
        service.map_cvss_to_severity = Mock()
        service.requires_version_upgrade = Mock()
        service.requires_config_change = Mock()
        service.requires_patch = Mock()
        
        return service
    
    @pytest.mark.asyncio
    async def test_assess_asset_vulnerabilities_complete(self, vulnerability_service, postgresql_asset, mock_nvd_vulnerabilities):
        """Test complete vulnerability assessment workflow"""
        # Mock the complete assessment result
        expected_assessment = Mock(
            asset_id=postgresql_asset.id,
            assessment_date=datetime.utcnow(),
            vulnerabilities=[
                Mock(cve_id="CVE-2023-1234", cvss_score=9.8, severity="CRITICAL"),
                Mock(cve_id="CVE-2023-5678", cvss_score=7.5, severity="HIGH")
            ],
            total_vulnerabilities=2,
            critical_vulnerabilities=1,
            high_vulnerabilities=1,
            vulnerability_score=4.2,
            remediation_recommendations=[
                Mock(priority=1, action="VERSION_UPGRADE"),
                Mock(priority=2, action="CONFIGURATION_CHANGE")
            ],
            next_scan_date=datetime.utcnow() + timedelta(days=7)
        )
        
        vulnerability_service.assess_asset_vulnerabilities.return_value = expected_assessment
        
        result = await vulnerability_service.assess_asset_vulnerabilities(postgresql_asset)
        
        assert result == expected_assessment
        assert result.asset_id == postgresql_asset.id
        assert result.total_vulnerabilities >= 0
        assert result.vulnerability_score >= 1.0 and result.vulnerability_score <= 5.0
        vulnerability_service.assess_asset_vulnerabilities.assert_called_once_with(postgresql_asset)
    
    @pytest.mark.asyncio
    async def test_generate_cpe_identifiers(self, vulnerability_service, postgresql_asset, sqlite_asset, duckdb_asset):
        """Test CPE identifier generation for different database types"""
        test_cases = [
            (postgresql_asset, ["cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"]),
            (sqlite_asset, ["cpe:2.3:a:sqlite:sqlite:3.42.0:*:*:*:*:*:*:*"]),
            (duckdb_asset, ["cpe:2.3:a:duckdb:duckdb:0.8.1:*:*:*:*:*:*:*"])
        ]
        
        for asset, expected_cpes in test_cases:
            vulnerability_service.generate_cpe_identifiers.return_value = expected_cpes
            
            result = await vulnerability_service.generate_cpe_identifiers(asset)
            
            assert result == expected_cpes
            assert len(result) > 0
            assert all(cpe.startswith("cpe:2.3:a:") for cpe in result)
            vulnerability_service.generate_cpe_identifiers.assert_called_with(asset)
    
    @pytest.mark.asyncio
    async def test_generate_cpe_identifiers_no_version(self, vulnerability_service):
        """Test CPE identifier generation when database version is unknown"""
        asset_no_version = Mock(
            asset_type="POSTGRESQL",
            database_version=None  # No version information
        )
        
        expected_cpe = ["cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*"]
        vulnerability_service.generate_cpe_identifiers.return_value = expected_cpe
        
        result = await vulnerability_service.generate_cpe_identifiers(asset_no_version)
        
        assert result == expected_cpe
        assert "*" in result[0]  # Should use wildcard for unknown version
    
    @pytest.mark.asyncio
    async def test_search_vulnerabilities_by_cpe(self, vulnerability_service, mock_nvd_vulnerabilities):
        """Test NIST NVD vulnerability search by CPE"""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        
        # Mock vulnerabilities returned from NVD search
        mock_vulnerabilities = [
            Mock(
                cve_id="CVE-2023-1234",
                description="SQL injection vulnerability",
                cvss_score=9.8,
                severity="CRITICAL",
                published_date=datetime(2023, 1, 15),
                last_modified=datetime(2023, 1, 20),
                cpe_matches=[cpe_identifier],
                references=["https://postgresql.org/security"],
                cwe_ids=["CWE-89"],
                exploit_available=True
            )
        ]
        
        vulnerability_service.search_vulnerabilities_by_cpe.return_value = mock_vulnerabilities
        
        result = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        assert result == mock_vulnerabilities
        assert len(result) > 0
        assert all(vuln.cve_id.startswith("CVE-") for vuln in result)
        vulnerability_service.search_vulnerabilities_by_cpe.assert_called_once_with(cpe_identifier)
    
    @pytest.mark.asyncio
    async def test_vulnerability_caching(self, vulnerability_service):
        """Test vulnerability data caching mechanism"""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        cache_key = f"cpe_{cpe_identifier}"
        
        # Mock cached vulnerabilities
        cached_vulnerabilities = [
            Mock(cve_id="CVE-2023-1234", cvss_score=9.8)
        ]
        
        # Simulate cache hit
        vulnerability_service.vulnerability_cache = {
            cache_key: {
                'vulnerabilities': cached_vulnerabilities,
                'timestamp': datetime.utcnow() - timedelta(hours=1)  # 1 hour old (fresh)
            }
        }
        
        vulnerability_service.search_vulnerabilities_by_cpe.return_value = cached_vulnerabilities
        
        result = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        assert result == cached_vulnerabilities
        # Should return cached data without making API call
    
    @pytest.mark.asyncio
    async def test_vulnerability_cache_expiry(self, vulnerability_service):
        """Test vulnerability cache expiry and refresh"""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        cache_key = f"cpe_{cpe_identifier}"
        
        # Mock expired cache entry
        vulnerability_service.vulnerability_cache = {
            cache_key: {
                'vulnerabilities': [Mock(cve_id="CVE-2023-OLD")],
                'timestamp': datetime.utcnow() - timedelta(hours=25)  # 25 hours old (expired)
            }
        }
        
        # Mock fresh vulnerabilities from API
        fresh_vulnerabilities = [
            Mock(cve_id="CVE-2023-NEW", cvss_score=8.5)
        ]
        
        vulnerability_service.search_vulnerabilities_by_cpe.return_value = fresh_vulnerabilities
        
        result = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        assert result == fresh_vulnerabilities
        # Should fetch fresh data due to cache expiry
    
    def test_calculate_vulnerability_score(self, vulnerability_service):
        """Test vulnerability score calculation algorithm"""
        test_cases = [
            # No vulnerabilities
            ([], 1.0),
            # Single critical vulnerability with exploit
            ([Mock(cvss_score=9.8, exploit_available=True, published_date=datetime.utcnow())], 4.5),
            # Multiple vulnerabilities of varying severity
            ([
                Mock(cvss_score=9.8, exploit_available=True, published_date=datetime.utcnow()),
                Mock(cvss_score=7.5, exploit_available=False, published_date=datetime.utcnow() - timedelta(days=30)),
                Mock(cvss_score=5.2, exploit_available=False, published_date=datetime.utcnow() - timedelta(days=90))
            ], 4.2),
            # Only low-severity vulnerabilities
            ([Mock(cvss_score=3.1, exploit_available=False, published_date=datetime.utcnow() - timedelta(days=180))], 2.1)
        ]
        
        for vulnerabilities, expected_score in test_cases:
            vulnerability_service.calculate_vulnerability_score.return_value = expected_score
            
            result = vulnerability_service.calculate_vulnerability_score(vulnerabilities)
            
            assert isinstance(result, (int, float))
            assert 1.0 <= result <= 5.0
            assert result == expected_score
    
    def test_map_cvss_to_severity(self, vulnerability_service):
        """Test CVSS score to severity level mapping"""
        test_cases = [
            (0.0, "NONE"),
            (0.1, "LOW"),
            (3.9, "LOW"),
            (4.0, "MEDIUM"),
            (6.9, "MEDIUM"),
            (7.0, "HIGH"),
            (8.9, "HIGH"),
            (9.0, "CRITICAL"),
            (10.0, "CRITICAL")
        ]
        
        for cvss_score, expected_severity in test_cases:
            vulnerability_service.map_cvss_to_severity.return_value = expected_severity
            
            result = vulnerability_service.map_cvss_to_severity(cvss_score)
            
            assert result == expected_severity
            vulnerability_service.map_cvss_to_severity.assert_called_with(cvss_score)
    
    @pytest.mark.asyncio
    async def test_check_exploit_availability(self, vulnerability_service):
        """Test exploit availability checking"""
        test_cases = [
            ("CVE-2023-1234", True),   # Known exploited vulnerability
            ("CVE-2023-5678", False),  # No known exploits
            ("CVE-2023-9012", False),  # No exploit data available
        ]
        
        for cve_id, expected_availability in test_cases:
            vulnerability_service.check_exploit_availability.return_value = expected_availability
            
            result = await vulnerability_service.check_exploit_availability(cve_id)
            
            assert isinstance(result, bool)
            assert result == expected_availability
            vulnerability_service.check_exploit_availability.assert_called_with(cve_id)
    
    @pytest.mark.asyncio
    async def test_generate_remediation_recommendations(self, vulnerability_service, postgresql_asset):
        """Test remediation recommendation generation"""
        # Mock vulnerabilities requiring different remediation strategies
        vulnerabilities = [
            Mock(cve_id="CVE-2023-1234", cvss_score=9.8, requires_version_upgrade=True),
            Mock(cve_id="CVE-2023-5678", cvss_score=7.5, requires_config_change=True),
            Mock(cve_id="CVE-2023-9012", cvss_score=5.2, requires_patch=True)
        ]
        
        expected_recommendations = [
            Mock(
                priority=1,
                action="VERSION_UPGRADE",
                description="Upgrade PostgreSQL to version 15.4",
                affected_vulnerabilities=["CVE-2023-1234"],
                estimated_effort_hours=8,
                business_impact="MEDIUM",
                technical_complexity="MEDIUM"
            ),
            Mock(
                priority=2,
                action="CONFIGURATION_CHANGE",
                description="Apply security configuration hardening",
                affected_vulnerabilities=["CVE-2023-5678"],
                estimated_effort_hours=4,
                business_impact="LOW",
                technical_complexity="LOW"
            ),
            Mock(
                priority=3,
                action="SECURITY_PATCH",
                description="Apply available security patches",
                affected_vulnerabilities=["CVE-2023-9012"],
                estimated_effort_hours=2,
                business_impact="LOW",
                technical_complexity="LOW"
            )
        ]
        
        vulnerability_service.generate_remediation_recommendations.return_value = expected_recommendations
        
        result = await vulnerability_service.generate_remediation_recommendations(postgresql_asset, vulnerabilities)
        
        assert result == expected_recommendations
        assert len(result) > 0
        assert all(rec.priority > 0 for rec in result)
        assert all(rec.estimated_effort_hours > 0 for rec in result)
        vulnerability_service.generate_remediation_recommendations.assert_called_once_with(postgresql_asset, vulnerabilities)
    
    @pytest.mark.asyncio
    async def test_get_latest_version(self, vulnerability_service):
        """Test latest version retrieval for different database types"""
        test_cases = [
            ("POSTGRESQL", "15.4"),
            ("SQLITE", "3.43.1"),
            ("DUCKDB", "0.9.1")
        ]
        
        for asset_type, expected_version in test_cases:
            vulnerability_service.get_latest_version.return_value = expected_version
            
            result = await vulnerability_service.get_latest_version(asset_type)
            
            assert result == expected_version
            assert isinstance(result, str)
            vulnerability_service.get_latest_version.assert_called_with(asset_type)


class TestVulnerabilityAssessmentPerformance:
    """Test suite for vulnerability assessment performance requirements"""
    
    @pytest.fixture
    def vulnerability_service(self):
        """Create mock service for performance testing"""
        service = Mock()
        service.assess_asset_vulnerabilities = AsyncMock()
        return service
    
    @pytest.mark.asyncio
    async def test_vulnerability_scan_performance(self, vulnerability_service, postgresql_asset):
        """Test vulnerability scan performance requirement (â‰¤ 10 minutes)"""
        # Mock a realistic vulnerability assessment that completes within time limit
        expected_assessment = Mock(
            asset_id=postgresql_asset.id,
            total_vulnerabilities=25,
            scan_duration_seconds=480  # 8 minutes
        )
        
        # Create async function that simulates realistic scan time
        async def realistic_scan():
            await asyncio.sleep(0.5)  # Simulate 500ms processing time for testing
            return expected_assessment
        
        vulnerability_service.assess_asset_vulnerabilities = realistic_scan
        
        start_time = time.time()
        result = await vulnerability_service.assess_asset_vulnerabilities(postgresql_asset)
        end_time = time.time()
        
        execution_time = (end_time - start_time) * 60  # Convert to minutes
        
        assert result == expected_assessment
        assert execution_time <= 10.0  # Performance requirement: â‰¤ 10 minutes
    
    @pytest.mark.asyncio
    async def test_concurrent_vulnerability_scans(self, vulnerability_service):
        """Test concurrent vulnerability scanning capability"""
        # Create multiple mock assets
        assets = [
            Mock(id=uuid4(), name=f"Database {i}", asset_type="POSTGRESQL")
            for i in range(5)
        ]
        
        # Mock assessment results
        def create_assessment(asset):
            return Mock(
                asset_id=asset.id,
                total_vulnerabilities=10,
                scan_duration_seconds=300
            )
        
        # Create async scan function
        async def scan_asset(asset):
            await asyncio.sleep(0.1)  # Simulate scan time
            return create_assessment(asset)
        
        vulnerability_service.assess_asset_vulnerabilities = scan_asset
        
        # Run concurrent scans
        start_time = time.time()
        tasks = [vulnerability_service.assess_asset_vulnerabilities(asset) for asset in assets]
        results = await asyncio.gather(*tasks)
        end_time = time.time()
        
        execution_time = end_time - start_time
        
        assert len(results) == len(assets)
        assert all(result.asset_id in [asset.id for asset in assets] for result in results)
        # Concurrent execution should be faster than sequential
        assert execution_time < (len(assets) * 0.1 * 1.5)  # Allow 50% overhead


class TestVulnerabilityAssessmentErrorHandling:
    """Test suite for error handling and resilience"""
    
    @pytest.fixture
    def vulnerability_service(self):
        """Create mock service for error testing"""
        service = Mock()
        service.search_vulnerabilities_by_cpe = AsyncMock()
        service.assess_asset_vulnerabilities = AsyncMock()
        return service
    
    @pytest.mark.asyncio
    async def test_nvd_api_error_handling(self, vulnerability_service):
        """Test NVD API error handling and fallback"""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        
        # Test API timeout
        vulnerability_service.search_vulnerabilities_by_cpe.side_effect = asyncio.TimeoutError("NVD API timeout")
        
        result = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        # Should return empty list on error, not raise exception
        assert result == []
    
    @pytest.mark.asyncio
    async def test_nvd_api_rate_limiting(self, vulnerability_service):
        """Test NVD API rate limiting handling"""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        
        # Test rate limiting response
        vulnerability_service.search_vulnerabilities_by_cpe.side_effect = Exception("Rate limit exceeded")
        
        result = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
        
        # Should handle rate limiting gracefully
        assert result == []
    
    @pytest.mark.asyncio
    async def test_invalid_cpe_handling(self, vulnerability_service):
        """Test handling of invalid CPE identifiers"""
        invalid_cpes = [
            "",  # Empty CPE
            "invalid_cpe_format",  # Invalid format
            "cpe:2.3:a:nonexistent:product:1.0:*:*:*:*:*:*:*",  # Non-existent product
        ]
        
        for invalid_cpe in invalid_cpes:
            vulnerability_service.search_vulnerabilities_by_cpe.return_value = []
            
            result = await vulnerability_service.search_vulnerabilities_by_cpe(invalid_cpe)
            
            # Should return empty list for invalid CPEs
            assert result == []
    
    @pytest.mark.asyncio
    async def test_asset_validation_errors(self, vulnerability_service):
        """Test asset validation error handling"""
        # Test with incomplete asset data
        incomplete_asset = Mock(
            id=None,  # Missing ID
            name="",  # Empty name
            asset_type=None,  # Missing type
            database_version=None
        )
        
        vulnerability_service.assess_asset_vulnerabilities.side_effect = ValueError("Invalid asset data")
        
        with pytest.raises(ValueError, match="Invalid asset data"):
            await vulnerability_service.assess_asset_vulnerabilities(incomplete_asset)
    
    @pytest.mark.asyncio
    async def test_network_connectivity_errors(self, vulnerability_service):
        """Test network connectivity error handling"""
        asset = Mock(id=uuid4(), asset_type="POSTGRESQL")
        
        # Test various network errors
        network_errors = [
            ConnectionError("Network unreachable"),
            OSError("DNS resolution failed"),
            Exception("SSL certificate verification failed")
        ]
        
        for error in network_errors:
            vulnerability_service.assess_asset_vulnerabilities.side_effect = error
            
            # Should handle network errors gracefully
            with pytest.raises(type(error)):
                await vulnerability_service.assess_asset_vulnerabilities(asset)


class TestVulnerabilityDataProcessing:
    """Test suite for vulnerability data processing and analysis"""
    
    @pytest.fixture
    def vulnerability_service(self):
        """Create mock service for data processing tests"""
        service = Mock()
        service.deduplicate_vulnerabilities = Mock()
        service.requires_version_upgrade = Mock()
        service.requires_config_change = Mock()
        service.requires_patch = Mock()
        return service
    
    def test_deduplicate_vulnerabilities(self, vulnerability_service):
        """Test vulnerability deduplication"""
        # Mock duplicate vulnerabilities
        vulnerabilities_with_duplicates = [
            Mock(cve_id="CVE-2023-1234", cvss_score=9.8),
            Mock(cve_id="CVE-2023-5678", cvss_score=7.5),
            Mock(cve_id="CVE-2023-1234", cvss_score=9.8),  # Duplicate
            Mock(cve_id="CVE-2023-9012", cvss_score=5.2),
        ]
        
        # Mock deduplicated result
        deduplicated_vulnerabilities = [
            Mock(cve_id="CVE-2023-1234", cvss_score=9.8),
            Mock(cve_id="CVE-2023-5678", cvss_score=7.5),
            Mock(cve_id="CVE-2023-9012", cvss_score=5.2),
        ]
        
        vulnerability_service.deduplicate_vulnerabilities.return_value = deduplicated_vulnerabilities
        
        result = vulnerability_service.deduplicate_vulnerabilities(vulnerabilities_with_duplicates)
        
        assert len(result) == 3  # Should remove duplicate
        assert result == deduplicated_vulnerabilities
        vulnerability_service.deduplicate_vulnerabilities.assert_called_once_with(vulnerabilities_with_duplicates)
    
    def test_remediation_strategy_classification(self, vulnerability_service):
        """Test vulnerability classification by remediation strategy"""
        vulnerabilities = [
            Mock(cve_id="CVE-2023-1234", description="Version-specific vulnerability"),
            Mock(cve_id="CVE-2023-5678", description="Configuration-related vulnerability"),
            Mock(cve_id="CVE-2023-9012", description="Patchable vulnerability"),
        ]
        
        # Test version upgrade requirement
        vulnerability_service.requires_version_upgrade.side_effect = [True, False, False]
        version_upgrade_vulns = [v for v in vulnerabilities if vulnerability_service.requires_version_upgrade(v)]
        assert len(version_upgrade_vulns) == 1
        
        # Test configuration change requirement
        vulnerability_service.requires_config_change.side_effect = [False, True, False]
        config_change_vulns = [v for v in vulnerabilities if vulnerability_service.requires_config_change(v)]
        assert len(config_change_vulns) == 1
        
        # Test patch requirement
        vulnerability_service.requires_patch.side_effect = [False, False, True]
        patch_vulns = [v for v in vulnerabilities if vulnerability_service.requires_patch(v)]
        assert len(patch_vulns) == 1


class TestVulnerabilityAssessmentIntegration:
    """Test suite for integration scenarios"""
    
    @pytest.mark.asyncio
    async def test_end_to_end_vulnerability_assessment(self, postgresql_asset):
        """Test complete end-to-end vulnerability assessment workflow"""
        # This test would be implemented when the actual service is available
        # For now, we'll create a mock workflow test
        
        # Mock the complete workflow
        service = Mock()
        
        # Step 1: Generate CPE identifiers
        service.generate_cpe_identifiers = AsyncMock(return_value=[
            "cpe:2.3:a:postgresql:postgresql:14.9:*:*:*:*:*:*:*"
        ])
        
        # Step 2: Search vulnerabilities
        service.search_vulnerabilities_by_cpe = AsyncMock(return_value=[
            Mock(cve_id="CVE-2023-1234", cvss_score=9.8, severity="CRITICAL")
        ])
        
        # Step 3: Calculate score
        service.calculate_vulnerability_score = Mock(return_value=4.2)
        
        # Step 4: Generate recommendations
        service.generate_remediation_recommendations = AsyncMock(return_value=[
            Mock(priority=1, action="VERSION_UPGRADE")
        ])
        
        # Step 5: Complete assessment
        service.assess_asset_vulnerabilities = AsyncMock(return_value=Mock(
            asset_id=postgresql_asset.id,
            total_vulnerabilities=1,
            vulnerability_score=4.2
        ))
        
        # Execute the workflow
        result = await service.assess_asset_vulnerabilities(postgresql_asset)
        
        assert result.asset_id == postgresql_asset.id
        assert result.total_vulnerabilities > 0
        assert result.vulnerability_score >= 1.0


if __name__ == "__main__":
    # Run the tests with verbose output and coverage
    pytest.main([
        __file__,
        "-v",
        "--cov=violentutf_api.fastapi_app.app.services.risk_assessment.vulnerability_service",
        "--cov-report=term-missing",
        "--tb=short"
    ])