#!/usr/bin/env python3
# Copyright (c) 2025 ViolentUTF Contributors.
# Licensed under the MIT License.
#
# This file is part of ViolentUTF - An AI Red Teaming Platform.
# See LICENSE file in the project root for license information.

"""Comprehensive tests for Vulnerability Assessment Service - Issue #282.

This module provides comprehensive test coverage for the vulnerability assessment
service including NIST NVD integration, CPE generation, CVSS scoring,
and remediation recommendations.

Test Coverage:
- Vulnerability assessment complete workflow
- NIST NVD API integration and caching
- CPE identifier generation for database assets
- CVSS score analysis and severity mapping
- Exploit availability checking
- Remediation recommendation engine
- Performance requirements (≤10 minutes per scan)
- Error handling and fallback mechanisms
"""

import asyncio
import os
import pytest
import sys
import time
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, patch

# Add the FastAPI app to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'violentutf_api', 'fastapi_app'))

from app.services.risk_assessment.vulnerability_service import (
    VulnerabilityAssessmentService, Vulnerability, RemediationRecommendation,
    VulnerabilityAssessment, VulnerabilitySeverity
)
from app.models.risk_assessment import (
    DatabaseAsset, AssetType, SecurityClassification, CriticalityLevel
)


class TestVulnerabilityAssessmentService:
    """Test suite for Vulnerability Assessment Service."""
    
    @pytest.fixture
    def vulnerability_service(self):
        """Create vulnerability service instance."""
        return VulnerabilityAssessmentService(
            nvd_api_key="test-api-key",
            cache_duration_hours=24
        )
    
    @pytest.fixture
    def mock_database_asset(self):
        """Create mock database asset for testing."""
        return DatabaseAsset(
            id="test-asset-uuid",
            name="Test PostgreSQL Database",
            asset_type=AssetType.POSTGRESQL,
            security_classification=SecurityClassification.CONFIDENTIAL,
            criticality_level=CriticalityLevel.HIGH,
            database_version="14.5",
            environment="production",
            location="datacenter-1"
        )
    
    @pytest.fixture
    def mock_vulnerabilities(self):
        """Create mock vulnerability list."""
        return [
            Vulnerability(
                cve_id="CVE-2023-39417",
                description="Critical SQL injection vulnerability",
                cvss_score=9.8,
                severity=VulnerabilitySeverity.CRITICAL,
                published_date=datetime(2023, 8, 15),
                last_modified=datetime(2023, 8, 20),
                cpe_matches=["cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"],
                references=["https://postgresql.org/security/CVE-2023-39417"],
                cwe_ids=["CWE-89"],
                exploit_available=True
            ),
            Vulnerability(
                cve_id="CVE-2023-39418",
                description="Authentication bypass vulnerability",
                cvss_score=7.5,
                severity=VulnerabilitySeverity.HIGH,
                published_date=datetime(2023, 7, 20),
                last_modified=datetime(2023, 7, 25),
                cpe_matches=["cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"],
                references=["https://postgresql.org/security/CVE-2023-39418"],
                cwe_ids=["CWE-287"],
                exploit_available=False
            ),
            Vulnerability(
                cve_id="CVE-2023-39419",
                description="Information disclosure vulnerability",
                cvss_score=5.3,
                severity=VulnerabilitySeverity.MEDIUM,
                published_date=datetime(2023, 6, 10),
                last_modified=datetime(2023, 6, 15),
                cpe_matches=["cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"],
                references=["https://postgresql.org/security/CVE-2023-39419"],
                cwe_ids=["CWE-200"],
                exploit_available=False
            )
        ]


class TestVulnerabilityAssessmentWorkflow(TestVulnerabilityAssessmentService):
    """Test complete vulnerability assessment workflow."""
    
    @pytest.mark.asyncio
    async def test_assess_asset_vulnerabilities_complete_workflow(self, vulnerability_service, 
                                                                mock_database_asset, mock_vulnerabilities):
        """Test complete vulnerability assessment workflow."""
        # Mock CPE generation and vulnerability search
        with patch.object(vulnerability_service, 'generate_cpe_identifiers') as mock_cpe, \
             patch.object(vulnerability_service, 'search_vulnerabilities_by_cpe') as mock_search, \
             patch.object(vulnerability_service, 'generate_remediation_recommendations') as mock_remediation:
            
            mock_cpe.return_value = ["cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"]
            mock_search.return_value = mock_vulnerabilities
            mock_remediation.return_value = [
                RemediationRecommendation(
                    priority=1,
                    action="VERSION_UPGRADE",
                    description="Upgrade PostgreSQL to version 15.4",
                    affected_vulnerabilities=["CVE-2023-39417", "CVE-2023-39418"],
                    estimated_effort_hours=8,
                    business_impact="MEDIUM",
                    technical_complexity="MEDIUM"
                )
            ]
            
            # Execute assessment
            result = await vulnerability_service.assess_asset_vulnerabilities(mock_database_asset)
            
            # Verify result structure
            assert isinstance(result, VulnerabilityAssessment)
            assert result.asset_id == "test-asset-uuid"
            assert result.total_vulnerabilities == 3
            assert result.critical_vulnerabilities == 1
            assert result.high_vulnerabilities == 1
            assert result.medium_vulnerabilities == 1
            assert result.low_vulnerabilities == 0
            assert 1.0 <= result.vulnerability_score <= 5.0
            assert len(result.remediation_recommendations) == 1
            assert result.scan_duration_seconds is not None
    
    @pytest.mark.asyncio
    async def test_assessment_performance_requirement(self, vulnerability_service, mock_database_asset):
        """Test vulnerability assessment meets ≤10 minutes performance requirement."""
        # Mock fast vulnerability scanning
        with patch.object(vulnerability_service, 'search_vulnerabilities_by_cpe') as mock_search:
            mock_search.return_value = []  # No vulnerabilities for fast test
            
            start_time = time.time()
            result = await vulnerability_service.assess_asset_vulnerabilities(mock_database_asset)
            duration_seconds = time.time() - start_time
            
            # Should complete well within 10 minutes (600 seconds)
            assert duration_seconds < 600
            assert result.scan_duration_seconds <= 600
    
    @pytest.mark.asyncio
    async def test_assessment_with_no_vulnerabilities(self, vulnerability_service, mock_database_asset):
        """Test assessment when no vulnerabilities are found."""
        with patch.object(vulnerability_service, 'search_vulnerabilities_by_cpe') as mock_search:
            mock_search.return_value = []  # No vulnerabilities
            
            result = await vulnerability_service.assess_asset_vulnerabilities(mock_database_asset)
            
            assert result.total_vulnerabilities == 0
            assert result.critical_vulnerabilities == 0
            assert result.vulnerability_score == 1.0  # Lowest score for no vulnerabilities
            assert len(result.vulnerabilities) == 0
    
    @pytest.mark.asyncio
    async def test_assessment_with_invalid_asset_data(self, vulnerability_service):
        """Test assessment with invalid asset data."""
        invalid_asset = DatabaseAsset(
            id=None,  # Invalid ID
            name="",  # Empty name
            asset_type=None  # Missing type
        )
        
        with pytest.raises(ValueError):
            await vulnerability_service.assess_asset_vulnerabilities(invalid_asset)


class TestCPEIdentifierGeneration(TestVulnerabilityAssessmentService):
    """Test CPE identifier generation for database assets."""
    
    @pytest.mark.asyncio
    async def test_postgresql_cpe_generation(self, vulnerability_service):
        """Test CPE generation for PostgreSQL assets."""
        asset = DatabaseAsset(
            id="test-uuid",
            name="PostgreSQL Database",
            asset_type=AssetType.POSTGRESQL,
            database_version="15.4"
        )
        
        cpe_identifiers = await vulnerability_service.generate_cpe_identifiers(asset)
        
        assert len(cpe_identifiers) == 1
        assert cpe_identifiers[0] == "cpe:2.3:a:postgresql:postgresql:15.4:*:*:*:*:*:*:*"
    
    @pytest.mark.asyncio 
    async def test_postgresql_cpe_without_version(self, vulnerability_service):
        """Test CPE generation for PostgreSQL without version."""
        asset = DatabaseAsset(
            id="test-uuid",
            name="PostgreSQL Database",
            asset_type=AssetType.POSTGRESQL,
            database_version=None
        )
        
        cpe_identifiers = await vulnerability_service.generate_cpe_identifiers(asset)
        
        assert len(cpe_identifiers) == 1
        assert cpe_identifiers[0] == "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*"
    
    @pytest.mark.asyncio
    async def test_sqlite_cpe_generation(self, vulnerability_service):
        """Test CPE generation for SQLite assets."""
        asset = DatabaseAsset(
            id="test-uuid",
            name="SQLite Database",
            asset_type=AssetType.SQLITE,
            database_version="3.42.0"
        )
        
        cpe_identifiers = await vulnerability_service.generate_cpe_identifiers(asset)
        
        assert len(cpe_identifiers) == 1
        assert cpe_identifiers[0] == "cpe:2.3:a:sqlite:sqlite:3.42.0:*:*:*:*:*:*:*"
    
    @pytest.mark.asyncio
    async def test_mysql_cpe_generation(self, vulnerability_service):
        """Test CPE generation for MySQL assets."""
        asset = DatabaseAsset(
            id="test-uuid",
            name="MySQL Database",
            asset_type=AssetType.MYSQL,
            database_version="8.0.34"
        )
        
        cpe_identifiers = await vulnerability_service.generate_cpe_identifiers(asset)
        
        assert len(cpe_identifiers) == 1
        assert cpe_identifiers[0] == "cpe:2.3:a:oracle:mysql:8.0.34:*:*:*:*:*:*:*"
    
    @pytest.mark.asyncio
    async def test_unsupported_asset_type(self, vulnerability_service):
        """Test CPE generation for unsupported asset types."""
        asset = DatabaseAsset(
            id="test-uuid", 
            name="Unsupported Database",
            asset_type="redis"  # Not in enum
        )
        
        cpe_identifiers = await vulnerability_service.generate_cpe_identifiers(asset)
        
        # Should return empty list for unsupported types
        assert len(cpe_identifiers) == 0


class TestVulnerabilitySearch(TestVulnerabilityAssessmentService):
    """Test vulnerability search and NIST NVD integration."""
    
    @pytest.mark.asyncio
    async def test_search_vulnerabilities_with_nvdlib(self, vulnerability_service):
        """Test vulnerability search using NIST NVD API."""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"
        
        # Mock nvdlib search
        with patch('violentutf_api.fastapi_app.app.services.risk_assessment.vulnerability_service.NVDLIB_AVAILABLE', True), \
             patch.object(vulnerability_service, '_search_nvd_api') as mock_nvd:
            
            mock_nvd.return_value = [
                Vulnerability(
                    cve_id="CVE-2023-TEST",
                    description="Test vulnerability",
                    cvss_score=7.5,
                    severity=VulnerabilitySeverity.HIGH,
                    published_date=datetime.utcnow(),
                    last_modified=datetime.utcnow(),
                    cpe_matches=[cpe_identifier],
                    references=[],
                    cwe_ids=[],
                    exploit_available=False
                )
            ]
            
            results = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
            
            assert len(results) == 1
            assert results[0].cve_id == "CVE-2023-TEST"
            mock_nvd.assert_called_once_with(cpe_identifier)
    
    @pytest.mark.asyncio
    async def test_search_vulnerabilities_with_mock_data(self, vulnerability_service):
        """Test vulnerability search using mock data (fallback)."""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"
        
        # Disable nvdlib to force mock data usage
        with patch('violentutf_api.fastapi_app.app.services.risk_assessment.vulnerability_service.NVDLIB_AVAILABLE', False):
            results = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
            
            # Should return mock PostgreSQL vulnerabilities
            assert len(results) >= 1
            assert all(isinstance(v, Vulnerability) for v in results)
            assert any("postgresql" in v.description.lower() for v in results)
    
    @pytest.mark.asyncio
    async def test_vulnerability_caching(self, vulnerability_service):
        """Test vulnerability result caching."""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"
        
        with patch.object(vulnerability_service, '_get_mock_vulnerabilities') as mock_get:
            mock_get.return_value = [MagicMock()]
            
            # First call should hit the service
            results1 = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
            
            # Second call should use cache
            results2 = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
            
            # Should only call mock service once due to caching
            mock_get.assert_called_once()
            assert len(results1) == len(results2)
    
    @pytest.mark.asyncio
    async def test_cache_expiration(self, vulnerability_service):
        """Test cache expiration behavior."""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"
        
        # Set short cache duration for testing
        vulnerability_service.cache_duration_hours = 0.001  # Very short
        
        with patch.object(vulnerability_service, '_get_mock_vulnerabilities') as mock_get:
            mock_get.return_value = [MagicMock()]
            
            # First call
            await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
            
            # Wait for cache to expire
            await asyncio.sleep(0.01)
            
            # Second call should hit service again
            await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
            
            # Should call service twice due to cache expiration
            assert mock_get.call_count == 2


class TestVulnerabilityScoring(TestVulnerabilityAssessmentService):
    """Test vulnerability scoring and severity mapping."""
    
    def test_cvss_to_severity_mapping(self, vulnerability_service):
        """Test CVSS score to severity level mapping."""
        assert vulnerability_service.map_cvss_to_severity(0.0) == VulnerabilitySeverity.NONE
        assert vulnerability_service.map_cvss_to_severity(3.5) == VulnerabilitySeverity.LOW
        assert vulnerability_service.map_cvss_to_severity(5.5) == VulnerabilitySeverity.MEDIUM
        assert vulnerability_service.map_cvss_to_severity(8.0) == VulnerabilitySeverity.HIGH
        assert vulnerability_service.map_cvss_to_severity(9.8) == VulnerabilitySeverity.CRITICAL
        
        # Test boundary conditions
        assert vulnerability_service.map_cvss_to_severity(3.9) == VulnerabilitySeverity.LOW
        assert vulnerability_service.map_cvss_to_severity(4.0) == VulnerabilitySeverity.MEDIUM
        assert vulnerability_service.map_cvss_to_severity(6.9) == VulnerabilitySeverity.MEDIUM
        assert vulnerability_service.map_cvss_to_severity(7.0) == VulnerabilitySeverity.HIGH
    
    def test_vulnerability_score_calculation_no_vulnerabilities(self, vulnerability_service):
        """Test vulnerability score calculation with no vulnerabilities."""
        score = vulnerability_service.calculate_vulnerability_score([])
        assert score == 1.0  # Minimum score when no vulnerabilities
    
    def test_vulnerability_score_calculation_with_vulnerabilities(self, vulnerability_service, mock_vulnerabilities):
        """Test vulnerability score calculation with various vulnerabilities."""
        score = vulnerability_service.calculate_vulnerability_score(mock_vulnerabilities)
        
        # Should be weighted higher due to critical vulnerabilities
        assert 3.0 <= score <= 5.0
        
        # Score should be influenced by exploit availability and recency
        critical_vuln = mock_vulnerabilities[0]  # Has exploit available
        assert critical_vuln.exploit_available
    
    def test_vulnerability_score_with_recent_vulnerabilities(self, vulnerability_service):
        """Test vulnerability scoring with recent vulnerabilities."""
        recent_vulns = [
            Vulnerability(
                cve_id="CVE-2023-RECENT",
                description="Recent critical vulnerability",
                cvss_score=9.5,
                severity=VulnerabilitySeverity.CRITICAL,
                published_date=datetime.utcnow() - timedelta(days=10),  # Very recent
                last_modified=datetime.utcnow(),
                cpe_matches=[],
                references=[],
                cwe_ids=[],
                exploit_available=True
            )
        ]
        
        old_vulns = [
            Vulnerability(
                cve_id="CVE-2020-OLD",
                description="Old critical vulnerability",
                cvss_score=9.5,
                severity=VulnerabilitySeverity.CRITICAL,
                published_date=datetime.utcnow() - timedelta(days=365),  # Old
                last_modified=datetime.utcnow(),
                cpe_matches=[],
                references=[],
                cwe_ids=[],
                exploit_available=True
            )
        ]
        
        recent_score = vulnerability_service.calculate_vulnerability_score(recent_vulns)
        old_score = vulnerability_service.calculate_vulnerability_score(old_vulns)
        
        # Recent vulnerabilities should score higher
        assert recent_score > old_score


class TestExploitAvailabilityChecking(TestVulnerabilityAssessmentService):
    """Test exploit availability checking functionality."""
    
    @pytest.mark.asyncio
    async def test_check_exploit_availability(self, vulnerability_service):
        """Test exploit availability checking."""
        # Test known exploitable CVE
        assert await vulnerability_service.check_exploit_availability("CVE-2023-39417") == True
        
        # Test unknown CVE
        assert await vulnerability_service.check_exploit_availability("CVE-2023-UNKNOWN") == False
        
        # Test well-known exploitable CVEs
        assert await vulnerability_service.check_exploit_availability("CVE-2021-44228") == True  # Log4j
    
    @pytest.mark.asyncio
    async def test_exploit_checking_performance(self, vulnerability_service):
        """Test exploit checking doesn't add significant delay."""
        start_time = time.time()
        
        # Check multiple CVEs
        cves = ["CVE-2023-39417", "CVE-2023-UNKNOWN", "CVE-2021-44228"]
        results = []
        
        for cve in cves:
            result = await vulnerability_service.check_exploit_availability(cve)
            results.append(result)
        
        duration = time.time() - start_time
        
        # Should complete quickly (within 1 second for 3 checks)
        assert duration < 1.0
        assert len(results) == 3


class TestRemediationRecommendations(TestVulnerabilityAssessmentService):
    """Test remediation recommendation generation."""
    
    @pytest.mark.asyncio
    async def test_generate_remediation_recommendations(self, vulnerability_service, 
                                                      mock_database_asset, mock_vulnerabilities):
        """Test remediation recommendation generation."""
        recommendations = await vulnerability_service.generate_remediation_recommendations(
            mock_database_asset, mock_vulnerabilities
        )
        
        assert len(recommendations) > 0
        assert all(isinstance(r, RemediationRecommendation) for r in recommendations)
        
        # Should be sorted by priority
        priorities = [r.priority for r in recommendations]
        assert priorities == sorted(priorities)
        
        # Should include version upgrade for vulnerability remediation
        version_upgrade = next((r for r in recommendations if r.action == "VERSION_UPGRADE"), None)
        assert version_upgrade is not None
        assert "15.4" in version_upgrade.description  # Latest PostgreSQL version
    
    @pytest.mark.asyncio
    async def test_recommendations_for_critical_vulnerabilities(self, vulnerability_service, mock_database_asset):
        """Test immediate mitigation recommendations for critical vulnerabilities."""
        critical_vulns = [
            Vulnerability(
                cve_id="CVE-2023-CRITICAL",
                description="Critical vulnerability with exploit",
                cvss_score=9.8,
                severity=VulnerabilitySeverity.CRITICAL,
                published_date=datetime.utcnow() - timedelta(days=5),
                last_modified=datetime.utcnow(),
                cpe_matches=[],
                references=[],
                cwe_ids=[],
                exploit_available=True
            )
        ]
        
        recommendations = await vulnerability_service.generate_remediation_recommendations(
            mock_database_asset, critical_vulns
        )
        
        # Should include immediate mitigation
        immediate_action = next((r for r in recommendations if r.action == "IMMEDIATE_MITIGATION"), None)
        assert immediate_action is not None
        assert immediate_action.priority == 1  # Highest priority
    
    @pytest.mark.asyncio
    async def test_recommendations_effort_estimation(self, vulnerability_service, mock_database_asset):
        """Test effort estimation for different asset types and environments."""
        # Test production PostgreSQL
        prod_asset = mock_database_asset
        prod_asset.environment = "production"
        prod_asset.criticality_level = CriticalityLevel.CRITICAL
        
        effort_hours = vulnerability_service._estimate_upgrade_effort(prod_asset)
        
        # Production critical asset should have higher effort estimate
        assert effort_hours >= 8  # Base PostgreSQL effort
        
        # Test development SQLite
        dev_asset = DatabaseAsset(
            id="dev-asset",
            name="Dev SQLite",
            asset_type=AssetType.SQLITE,
            environment="development",
            criticality_level=CriticalityLevel.LOW
        )
        
        dev_effort = vulnerability_service._estimate_upgrade_effort(dev_asset)
        
        # Development SQLite should have lower effort
        assert dev_effort < effort_hours
    
    @pytest.mark.asyncio
    async def test_business_impact_assessment(self, vulnerability_service, mock_database_asset):
        """Test business impact assessment for recommendations."""
        impact = vulnerability_service._assess_upgrade_business_impact(mock_database_asset)
        
        # Production high-criticality asset should have high business impact
        assert impact == "HIGH"
        
        # Test with development asset
        dev_asset = mock_database_asset
        dev_asset.environment = "development"
        dev_asset.criticality_level = CriticalityLevel.LOW
        
        dev_impact = vulnerability_service._assess_upgrade_business_impact(dev_asset)
        assert dev_impact == "LOW"


class TestErrorHandling(TestVulnerabilityAssessmentService):
    """Test error handling and fallback mechanisms."""
    
    @pytest.mark.asyncio
    async def test_nvd_api_failure_fallback(self, vulnerability_service):
        """Test fallback to mock data when NVD API fails."""
        cpe_identifier = "cpe:2.3:a:postgresql:postgresql:14.5:*:*:*:*:*:*:*"
        
        with patch.object(vulnerability_service, '_search_nvd_api') as mock_nvd:
            mock_nvd.side_effect = Exception("API failure")
            
            # Should fallback to mock data and not raise exception
            results = await vulnerability_service.search_vulnerabilities_by_cpe(cpe_identifier)
            
            # Should still return empty list gracefully
            assert isinstance(results, list)
    
    @pytest.mark.asyncio
    async def test_assessment_with_service_unavailable(self, vulnerability_service, mock_database_asset):
        """Test assessment when external services are unavailable."""
        # Mock all external calls to fail
        with patch.object(vulnerability_service, 'search_vulnerabilities_by_cpe') as mock_search:
            mock_search.side_effect = Exception("Service unavailable")
            
            # Assessment should handle gracefully and return result
            result = await vulnerability_service.assess_asset_vulnerabilities(mock_database_asset)
            
            assert isinstance(result, VulnerabilityAssessment)
            assert result.total_vulnerabilities == 0
            assert result.vulnerability_score == 1.0  # Safe default
    
    def test_invalid_cvss_score_handling(self, vulnerability_service):
        """Test handling of invalid CVSS scores."""
        invalid_vulns = [
            Vulnerability(
                cve_id="CVE-INVALID",
                description="Invalid CVSS score",
                cvss_score=-1.0,  # Invalid score
                severity=VulnerabilitySeverity.MEDIUM,
                published_date=datetime.utcnow(),
                last_modified=datetime.utcnow(),
                cpe_matches=[],
                references=[],
                cwe_ids=[],
                exploit_available=False
            )
        ]
        
        # Should handle gracefully and not crash
        score = vulnerability_service.calculate_vulnerability_score(invalid_vulns)
        assert 1.0 <= score <= 5.0


class TestPerformanceAndScalability(TestVulnerabilityAssessmentService):
    """Test performance and scalability requirements."""
    
    @pytest.mark.asyncio
    async def test_concurrent_vulnerability_scans(self, vulnerability_service):
        """Test concurrent vulnerability scanning capability."""
        assets = [
            DatabaseAsset(
                id=f"asset-{i}",
                name=f"Test Asset {i}",
                asset_type=AssetType.POSTGRESQL,
                database_version="14.5"
            )
            for i in range(5)
        ]
        
        # Mock vulnerability search to return quickly
        with patch.object(vulnerability_service, 'search_vulnerabilities_by_cpe') as mock_search:
            mock_search.return_value = []
            
            start_time = time.time()
            
            # Run concurrent assessments
            tasks = [
                vulnerability_service.assess_asset_vulnerabilities(asset)
                for asset in assets
            ]
            results = await asyncio.gather(*tasks)
            
            duration = time.time() - start_time
            
            # All should complete successfully
            assert len(results) == 5
            assert all(isinstance(r, VulnerabilityAssessment) for r in results)
            
            # Concurrent execution should be efficient
            assert duration < 5.0  # Should complete much faster than 5 sequential scans
    
    @pytest.mark.asyncio
    async def test_large_vulnerability_list_handling(self, vulnerability_service, mock_database_asset):
        """Test handling of large vulnerability lists."""
        # Create large list of mock vulnerabilities
        large_vuln_list = [
            Vulnerability(
                cve_id=f"CVE-2023-{i:05d}",
                description=f"Test vulnerability {i}",
                cvss_score=5.0 + (i % 5),  # Vary scores
                severity=VulnerabilitySeverity.MEDIUM,
                published_date=datetime.utcnow() - timedelta(days=i),
                last_modified=datetime.utcnow(),
                cpe_matches=[],
                references=[],
                cwe_ids=[],
                exploit_available=(i % 10 == 0)  # Some with exploits
            )
            for i in range(100)  # 100 vulnerabilities
        ]
        
        with patch.object(vulnerability_service, 'search_vulnerabilities_by_cpe') as mock_search:
            mock_search.return_value = large_vuln_list
            
            start_time = time.time()
            result = await vulnerability_service.assess_asset_vulnerabilities(mock_database_asset)
            duration = time.time() - start_time
            
            # Should handle large list efficiently
            assert duration < 10.0  # Should complete within 10 seconds
            assert result.total_vulnerabilities == 100
            assert len(result.vulnerabilities) == 100


# Test fixtures for async testing
@pytest.fixture
def event_loop():
    """Create event loop for async tests."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


# Test markers
pytestmark = [
    pytest.mark.vulnerability_service,
    pytest.mark.nist_nvd,
    pytest.mark.performance,
    pytest.mark.issue_282
]


if __name__ == "__main__":
    # Run tests with coverage reporting
    pytest.main([
        __file__,
        "-v",
        "--cov=violentutf_api.fastapi_app.app.services.risk_assessment.vulnerability_service",
        "--cov-report=html", 
        "--cov-report=term-missing",
        "--cov-min=92"  # 92% minimum coverage requirement
    ])